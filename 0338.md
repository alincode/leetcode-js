# 338. Counting Bits

<https://leetcode.com/problems/counting-bits/>

這個問題要求對於給定的非負整數 n，計算出從 0 到 n 的每個數字的二進位表示中包含的 1 的個數。我們需要返回一個陣列，其中每個位置 i 的值表示數字 i 的二進位表示中包含的 1 的個數。

例如，當 n = 5 時，期望的輸出是 [0, 1, 1, 2, 1, 2]，因為從 0 到 5 的每個數字的二進位表示中包含的 1 的個數為 [0, 1, 1, 2, 1, 2]。

## DP 解法

一種常見的解法是使用動態規劃的思想。我們可以觀察到以下規律：

- 如果一個數字是偶數，那麼它的二進位表示中包含的 1 的個數與它除以 2 後的數字的二進位表示中包含的 1 的個數相同。
- 如果一個數字是奇數，那麼它的二進位表示中包含的 1 的個數比它除以 2 後的數字的二進位表示中包含的 1 的個數多 1。

基於以上觀察，我們可以定義狀態 dp[i] 表示數字 i 的二進位表示中包含的 1 的個數。根據上述規律，我們可以得到以下狀態轉移方程：

- 如果 i 是偶數，則 dp[i] = dp[i / 2]。
- 如果 i 是奇數，則 dp[i] = dp[i / 2] + 1。

接下來，我們可以使用迴圈來計算從 0 到 n 的每個數字的二進位表示中包含的 1 的個數。最終返回這個計算結果即可。

以下是使用動態規劃解法的程式碼示例：

```javascript
var countBits = function (n) {
  const dp = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    dp[i] = dp[Math.floor(i / 2)] + (i % 2);
  }
  return dp;
};
```

該解法的時間複雜度為 O(n)，其中 n 是給定的非負整數。因為我們需要計算從 0 到 n 的每個數字的二進位表示中包含的 1 的個數，所以迴圈遍歷了 n 個數字。空間複雜度為 O(n)，因為我們使用了一個長度為 n+1 的陣列 dp 來存儲計算結果。

## DP 解法

```js
var countBits = function (num) {
  let dp = [0];
  let offset = 1;
  for (let n = 1; n <= num; n++) {
    if (n === offset * 2) offset = n;
    dp[n] = 1 + dp[n - offset];
  }
  return dp;
};
```

ps. NeetCode 使用的解法

這個解法的時間複雜度是 O(num)，空間複雜度是 O(num)，因為我們需要建立一個大小為 num+1 的 dp 數組。

## Bit Manipulation 解法

除了使用動態規劃的解法，還有一種更優化的解法稱為 `Brian Kernighan's Algorithm`。這種解法利用位運算的性質，可以在較短的時間內計算出每個數字的二進位表示中包含的 1 的個數。

該解法的思路如下：

- 對於任意非負整數 num，num & (num - 1) 可以將 num 最右邊的 1 變成 0。
- 我們可以利用這個性質，不斷將 num 中的最右邊的 1 變成 0，同時計算變化的次數，直到 num 變為 0。

以下是使用 `Brian Kernighan's Algorithm` 解法的程式碼示例：

```javascript
var countBits = function (n) {
  const result = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    result[i] = result[i & (i - 1)] + 1;
  }
  return result;
};
```

該解法的時間複雜度為 O(n)，空間複雜度為 O(n)。與動態規劃解法相比，這種解法的計算速度更快，因為它利用了位運算的特性，不需要額外的迴圈來計算每個數字的二進位表示中包含的 1 的個數。

### Brian Kernighan's 演算法

Brian Kernighan's 演算法，也被稱為「計算位元數」演算法，是一種在二進制數字中計算設定位元（值為 1 的位元）數量的有效方法。

該演算法通過反覆清除數字的最低有效位元，直到所有位元都被清除來實現。它通過使用數字和它的減量（數字-1）進行位元與運算，有效地將最低有效位元翻轉為 0。

以下是該演算法的基本思想：

1. 將計數變數初始化為 0。
2. 當數字不為零時：
   - 將計數增加 1。
   - 對數字和它的減量（數字-1）執行位元與運算，以清除最低有效位元。
   - 使用位元與運算的結果更新數字。
3. 返回計數。

該演算法利用了以下事實：對數字和它的減量執行位元與運算會清除最低有效位元。通過反覆應用這個操作，我們可以計算原始數字中設定位元的數量。

以下是 JavaScript 中 Brian Kernighan's 演算法的示例實現：

```javascript
var countBits = function (n) {
  let count = 0;
  while (n !== 0) {
    count++;
    n &= n - 1;
  }
  return count;
};
```

該演算法的時間複雜度為 O(k)，其中 k 是輸入數字中設定位元的數量。在最壞情況下，當所有位元都被設定時，時間複雜度為 O(log n)，其中 n 是輸入數字。空間複雜度為 O(1)，因為它只需要一個常量量的額外空間來存儲計數變數。
