# 338. Counting Bits

<https://leetcode.com/problems/counting-bits/>

這個問題要求對於給定的非負整數 n，計算出從 0 到 n 的每個數字的二進位表示中包含的 1 的個數。我們需要返回一個陣列，其中每個位置 i 的值表示數字 i 的二進位表示中包含的 1 的個數。

例如，當 n = 5 時，期望的輸出是 [0, 1, 1, 2, 1, 2]，因為從 0 到 5 的每個數字的二進位表示中包含的 1 的個數為 [0, 1, 1, 2, 1, 2]。

## DP 解法

一種常見的解法是使用動態規劃的思想。我們可以觀察到以下規律：

- 如果一個數字是偶數，那麼它的二進位表示中包含的 1 的個數與它除以 2 後的數字的二進位表示中包含的 1 的個數相同。
- 如果一個數字是奇數，那麼它的二進位表示中包含的 1 的個數比它除以 2 後的數字的二進位表示中包含的 1 的個數多 1。

基於以上觀察，我們可以定義狀態 dp[i] 表示數字 i 的二進位表示中包含的 1 的個數。根據上述規律，我們可以得到以下狀態轉移方程：

- 如果 i 是偶數，則 dp[i] = dp[i / 2]。
- 如果 i 是奇數，則 dp[i] = dp[i / 2] + 1。

接下來，我們可以使用迴圈來計算從 0 到 n 的每個數字的二進位表示中包含的 1 的個數。最終返回這個計算結果即可。

以下是使用動態規劃解法的程式碼示例：

```javascript
var countBits = function (n) {
  const dp = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    dp[i] = dp[Math.floor(i / 2)] + (i % 2);
  }
  return dp;
};
```

該解法的時間複雜度為 O(n)，其中 n 是給定的非負整數。因為我們需要計算從 0 到 n 的每個數字的二進位表示中包含的 1 的個數，所以迴圈遍歷了 n 個數字。空間複雜度為 O(n)，因為我們使用了一個長度為 n+1 的陣列 dp 來存儲計算結果。

## Bit Manipulation 解法

除了使用動態規劃的解法，還有一種更優化的解法稱為「Brian Kernighan's Algorithm」。這種解法利用位運算的性質，可以在較短的時間內計算出每個數字的二進位表示中包含的 1 的個數。

該解法的思路如下：

- 對於任意非負整數 num，num & (num - 1) 可以將 num 最右邊的 1 變成 0。
- 我們可以利用這個性質，不斷將 num 中的最右邊的 1 變成 0，同時計算變化的次數，直到 num 變為 0。

以下是使用 Brian Kernighan's Algorithm 解法的程式碼示例：

```javascript
var countBits = function (n) {
  const result = new Array(n + 1).fill(0);
  for (let i = 1; i <= n; i++) {
    result[i] = result[i & (i - 1)] + 1;
  }
  return result;
};
```

該解法的時間複雜度為 O(n)，空間複雜度為 O(n)。與動態規劃解法相比，這種解法的計算速度更快，因為它利用了位運算的特性，不需要額外的迴圈來計算每個數字的二進位表示中包含的 1 的個數。
