# 191. Number of 1 Bits

這個問題要求我們計算一個無符號整數的二進位表示中 '1' 的個數，也稱為「漢明重量」（Hamming weight）。漢明重量是一個整數在二進位表示中 '1' 的總數。

### 什麼是 Hamming weight

Hamming weight 是指在一個數的二進位表示中，'1' 的總數。也稱為 population count 或 bit count。這個概念得名自電腦科學家 Richard Hamming。

例如，數字 10 的二進位表示為 1010，其中有 2 個 '1'，所以它的 Hamming weight 是 2。

Hamming weight 在許多計算機科學和電子工程的應用中都很重要，例如在位元運算、錯誤檢測和訊號處理等領域。在計算機科學中，常常會使用 Hamming weight 來解決一些二進位相關的問題，如計算二進位中 '1' 的個數、驗證校驗碼等。

## Brian Kernighan 解法

```js
var hammingWeight = function (n) {
  let res = 0;
  while (n) {
    n &= n - 1;
    res += 1;
  }
  return res;
};
```

這個解法使用了 Brian Kernighan's Algorithm，用於計算一個數字的二進制表示中有多少個位是 1，也就是所謂的「Hamming weight」。

該解法的基本思想是，對於一個數字 n，不斷地將最右邊的 1 取反為 0，直到 n 變成 0。每次將最右邊的 1 取反為 0，就代表找到了一個位元為 1 的位置，所以每完成一次操作，就將結果加一。

具體的步驟如下：

1. 創建一個變數 `res` 用於記錄結果，初始化為 0。
2. 使用一個循環，當 `n` 不為 0 時，執行以下操作：
   - 使用位元運算 `n &= n - 1`，這個操作會將 `n` 的最右邊的 1 取反為 0。
   - 將 `res` 加 1，表示找到了一個位元為 1 的位置。
3. 當 `n` 變成 0 時，結束循環，返回 `res`，即為 Hamming weight 的結果。

這種解法的關鍵在於每次操作都會消去 `n` 的最右邊的 1，所以循環的次數等於 `n` 的二進制表示中 1 的個數，因此時間複雜度與 `n` 的位元中 1 的個數相關，即為 O(1) 到 O(log n) 之間。

這種解法的優點是非常高效，因為它不需要遍歷所有位元，只需要處理二進制表示中為 1 的位元即可。所以在處理大數字時，它比其他解法更快速且節省空間。

## Bit Manipulation 解法 (右移位元的解法)

```javascript
var hammingWeight = function (n) {
  let count = 0;
  while (n !== 0) {
    if (n & 1) count++;
    n = n >>> 1;
  }
  return count;
};
```

你可以呼叫這個函式並傳入一個無符號整數 n，它會回傳 n 的二進位表示中 '1' 的個數。例如：

```javascript
console.log(hammingWeight(5)); // 輸出 2，二進位表示為 101，有 2 個 '1'
console.log(hammingWeight(10)); // 輸出 2，二進位表示為 1010，有 2 個 '1'
```

這個函式使用位元 AND 和無符號右移運算，在迴圈中將 n 的二進位表示的每個位元逐個檢查，如果是 '1' 則將計數 count 加一，最後返回 count 即可。

這個解法的時間複雜度是 O(1)，空間複雜度也是 O(1)。

在這個解法中，我們使用了一個 while 迴圈來計算 n 的 Hamming weight。在迴圈中，我們每次都將 n 右移一位（使用 `n >>> 1`），然後檢查 n 的最後一位是否為 1（使用 `n & 1`），如果是則計算加一。迴圈的運行次數取決於 n 的二進位表示中有多少位是 1。由於輸入的 n 是一個 32 位整數，因此迴圈最多運行 32 次。因此，時間複雜度是 O(1)。

此外，我們只使用了一個變數 `count` 來保存計數結果，並沒有使用其他與輸入大小相關的額外資源。因此，空間複雜度也是 O(1)。

### 前面兩種解法相比

使用 Brian Kernighan's Algorithm 的解法在處理大數字時，效率通常更高。這是因為該解法不需要遍歷所有位元，而是根據二進制表示中 1 的個數進行運算，循環的次數取決於 1 的個數。因此，它的時間複雜度在最壞情況下是 O(log n)。

另一方面，使用右移位元的解法，雖然這個解法也能正確地計算 Hamming weight，但是每次循環都需要進行右移位元操作，可能需要更多的循環次數來處理大數字。在最壞情況下，當 n 是一個非常大的數字時，循環次數可能達到 32 或 64 次，取決於 JavaScript 的數字位元長度。

綜合來說，使用 Brian Kernighan's Algorithm 的解法在效率上更優，特別是處理大數字時。它是一種更加高效的位元操作方式，所以通常會比右移位元的解法快速。因此，如果要求效率，建議使用第一種解法。

## Divide and Conquer 解法

```javascript
var hammingWeight = function (n) {
  if (n === 0) return 0;
  return (n & 1) + hammingWeight(n >>> 1);
};
```

這個解法是一種遞迴的方式來計算一個數字的 Hamming weight，即二進制表示中 1 的個數。它的基本思想是每次取出 n 的最後一位（即 `n & 1`），並將 n 右移一位（即 `n >>> 1`），然後將這兩個結果相加，最終得到 Hamming weight。

這個解法是使用遞迴的方式來處理數字的二進制表示。首先，我們檢查 n 是否為 0，如果是則返回 0，因為 0 的 Hamming weight 為 0。

然後，我們對 n 做兩個操作：`n & 1` 和 `n >>> 1`。`n & 1` 的結果是 n 的最後一位，如果最後一位是 1，則結果為 1，否則為 0。`n >>> 1` 是將 n 右移一位，相當於把最後一位去掉。這樣我們就得到了 n 中 1 的個數和 n 去掉最後一位的結果。

接著，我們將這兩個結果相加，得到的就是 n 的 Hamming weight。這裡使用遞迴的方式，不斷對 n 去掉最後一位，直到 n 為 0 為止。每次遞迴都對 n 做了兩次操作，所以時間複雜度為 `O(log n)`。

這個解法使用了遞迴，因此需要額外的函數調用和堆棧空間。在最壞情況下，遞迴的深度可能達到數字的位元長度，因此空間複雜度也為 `O(log n)`。總體而言，這個解法是一個高效且簡潔的方式來計算 Hamming weight。

## 補充

在 JavaScript 中，`>>>` 和 `>>` 都是位元運算符，用於對數字進行位元運算。它們之間的主要差異在於處理有符號數和無符號數的方式。

1. `>>>`（無符號右移位元運算符）：

   - 對於正數和 0，`>>>` 與 `>>` 的效果是一樣的，即右移指定的位數，左邊空出的位補零。
   - 對於負數，`>>>` 的行為不同於 `>>`。`>>>` 會將所有位都右移，並且左邊空出的位用 0 填充。這意味著無符號右移會將負數轉換成正數。

2. `>>`（有符號右移位元運算符）：
   - 對於正數和 0，`>>` 與 `>>>` 的效果是一樣的，即右移指定的位數，左邊空出的位用符號位填充，即如果原數字最高位是 0，則補 0；如果最高位是 1，則補 1。
   - 對於負數，`>>` 會將所有位都右移，並且左邊空出的位用符號位填充。這意味著有符號右移會保持負數的負號不變。

例如：

- 對於二進位數字 `1010`，右移 1 位，`1010 >>> 1` 會得到 `0101`，而 `1010 >> 1` 也會得到 `0101`。
- 對於二進位數字 `1101`（-3 的二進位表示），右移 1 位，`1101 >>> 1` 會得到 `0110`（6 的二進位表示），而 `1101 >> 1` 會得到 `1110`（-2 的二進位表示）。

在一些情況下，使用 `>>>` 和 `>>` 可能會導致不同的結果，特別是當處理負數時。因此，在使用位元運算符時，需要根據具體的需求和數字的符號性質選擇適當的運算符。
