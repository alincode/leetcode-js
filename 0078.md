# 78. Subsets

這個問題要求找到給定數組的所有子集。子集是指在不改變元素順序的情況下，從原始數組中選擇任意個元素（包括空集和原始數組本身）的集合。

## Backtracking 解法

```javascript
var subsets = function (nums) {
  const result = [];

  function backtrack(currSubset, start) {
    result.push(currSubset.slice()); // 將當前子集加入結果列表

    for (let i = start; i < nums.length; i++) {
      currSubset.push(nums[i]); // 將當前數字加入子集
      backtrack(currSubset, i + 1); // 遞歸生成下一個數字的子集
      currSubset.pop(); // 回溯，刪除最後一個數字
    }
  }

  backtrack([], 0);
  return result;
};
```

這個解法使用回溯法（Backtracking）的思想，通過遞歸生成所有可能的子集。從數組的每個位置開始，遞歸生成包含該位置元素的子集，然後進一步遞歸生成不包含該位置元素的子集。通過不斷遞歸生成，最終可以得到所有的子集。

該解法的時間複雜度為 O(2^N)，其中 N 為給定數組的長度。因為每個元素在子集中可以存在或不存在，所以總共會有 2^N 個子集。空間複雜度為 O(N)，用於存儲遞歸過程中的臨時子集。

## Bit Manipulation 解法

除了回溯法，還有一種解法是使用位操作（Bit Manipulation）來生成所有子集。

這種解法的思路是，將數組中的每個元素看作二進制位，對應到子集中的每個位置。如果該元素在子集中存在，則對應位置的二進制位為 1，否則為 0。通過遍歷從 0 到 2^N-1 的二進制數字，可以得到所有子集。

以下是使用位操作解法的範例程式碼：

```javascript
var subsets = function (nums) {
  const result = [];
  const n = nums.length;
  const subsetCount = 2 ** n;

  for (let i = 0; i < subsetCount; i++) {
    const currSubset = [];
    for (let j = 0; j < n; j++) {
      if ((i >> j) & 1) {
        currSubset.push(nums[j]);
      }
    }
    result.push(currSubset);
  }

  return result;
};
```

這個解法的時間複雜度和空間複雜度都是 O(2^N)，其中 N 為給定數組的長度。這是因為總共有 2^N 個子集，需要遍歷所有的二進制數字來生成子集，並且每個子集需要 O(N)的空間來存儲。這種解法比回溯法更為高效，但在理解和實現上較為複雜。
