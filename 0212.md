# 212. Word Search II

這個問題是經典的「單詞搜尋」問題，主要目標是在給定的字母矩陣（board）中尋找包含在給定單詞列表（words）中的單詞。可以使用深度優先搜索（DFS）或字典樹（Trie）等方法來解決這個問題。

以下是一個使用 Trie 數據結構的解決方案：

```javascript
class TrieNode {
  constructor() {
    this.children = {};
    this.isEndOfWord = false;
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode();
  }

  insert(word) {
    let node = this.root;
    for (const char of word) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode();
      }
      node = node.children[char];
    }
    node.isEndOfWord = true;
  }

  search(word) {
    let node = this.root;
    for (const char of word) {
      if (!node.children[char]) {
        return false;
      }
      node = node.children[char];
    }
    return node.isEndOfWord;
  }
}

var findWords = function (board, words) {
  const trie = new Trie();
  for (const word of words) {
    trie.insert(word);
  }

  const result = [];
  const rows = board.length;
  const cols = board[0].length;

  const dfs = (node, r, c, path) => {
    if (r < 0 || r >= rows || c < 0 || c >= cols) return;
    const char = board[r][c];
    if (!node.children[char]) return;

    path += char;
    const nextNode = node.children[char];
    if (nextNode.isEndOfWord) {
      result.push(path);
      nextNode.isEndOfWord = false; // 避免重複添加同一單詞
    }

    board[r][c] = "#"; // 標記已經訪問過的位置
    dfs(nextNode, r + 1, c, path);
    dfs(nextNode, r - 1, c, path);
    dfs(nextNode, r, c + 1, path);
    dfs(nextNode, r, c - 1, path);
    board[r][c] = char; // 還原位置狀態
  };

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) dfs(trie.root, r, c, "");
  }

  return result;
};
```

這個解法使用 Trie 數據結構來優化查找過程，遞歸地在字母矩陣中搜索符合 Trie 中的單詞。遞歸的過程中，我們同時保持了矩陣中每個位置的狀態，確保不會重複訪問同一個位置。這樣可以確保我們只找到符合條件的單詞，同時不重複計算。
