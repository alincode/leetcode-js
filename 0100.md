# 100. Same Tree

問題：給定兩個二叉樹的根節點 p 和 q，判斷它們是否相同。

## DFS 解法

```javascript
var isSameTree = function (p, q) {
  // 如果兩個節點都為空，則認為它們相同
  if (!p && !q) {
    return true;
  }
  // 如果其中一個節點為空，則認為它們不相同
  if (!p || !q) {
    return false;
  }
  // 如果兩個節點的值不相等，則認為它們不相同
  if (p.val !== q.val) {
    return false;
  }
  // 遞歸檢查兩個節點的左子樹和右子樹是否相同
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

這個解法使用遞歸的方式來判斷兩個二叉樹是否相同。我們首先檢查兩個節點是否都為空，如果是，則認為它們相同。如果其中一個節點為空，則認為它們不相同。接著檢查兩個節點的值是否相等，如果不相等，則認為它們不相同。最後，遞歸地檢查兩個節點的左子樹和右子樹是否相同，如果都相同，則認為整個二叉樹相同。

這個解法的時間複雜度是 O(n)，其中 n 是二叉樹中的節點數量。因為我們需要遍歷所有節點來進行比較。空間複雜度是 O(h)，其中 h 是二叉樹的高度。在遞歸過程中，會使用系統堆棧來保存遞歸調用的上下文。最壞情況下，當二叉樹為鏈狀結構時，堆棧的深度為 h，所以空間複雜度為 O(h)。

## BFS 解法

另一種解法是使用迭代的方式來判斷兩個二叉樹是否相同。我們可以使用兩個佇列（Queue）來分別儲存兩個二叉樹的節點，然後逐個比較對應位置上的節點值是否相同。

以下是使用迭代的解法：

```javascript
var isSameTree = function (p, q) {
  const queue1 = [p];
  const queue2 = [q];

  while (queue1.length && queue2.length) {
    const node1 = queue1.shift();
    const node2 = queue2.shift();

    if (!node1 && !node2) {
      continue;
    }

    if (!node1 || !node2 || node1.val !== node2.val) {
      return false;
    }

    queue1.push(node1.left);
    queue1.push(node1.right);
    queue2.push(node2.left);
    queue2.push(node2.right);
  }

  return queue1.length === 0 && queue2.length === 0;
};
```

這個解法使用兩個佇列來存儲兩個二叉樹的節點，然後進行迭代比較。在每一輪迭代中，從兩個佇列中取出一個節點進行比較。如果其中一個節點為空，則略過該輪比較。如果兩個節點都不為空，但節點值不相等，則認為二叉樹不相同。否則，將兩個節點的左子樹和右子樹按順序加入到佇列中，繼續下一輪迭代。最終，如果兩個佇列都為空，則認為兩個二叉樹相同；否則，認為不相同。

這個解法的時間複雜度和空間複雜度都是 O(n)，其中 n 是二叉樹中的節點數量。因為在迭代過程中，我們需要遍歷所有節點進行比較，並且同時使用兩個佇列來存儲節點。

這兩種解法的主要差異在於遞迴和迭代的使用方式。

1. 遞迴解法：

   - 使用遞迴的方式進行深度優先搜索（DFS）。
   - 以遞迴的方式來遍歷兩個二叉樹的節點並進行比較。
   - 遞迴解法較為簡潔，代碼量較少，容易理解和實現。
   - 遞迴解法的時間複雜度和空間複雜度均為 O(n)，其中 n 是二叉樹中的節點數量。遞迴的過程中，需要遍歷所有節點進行比較，並且遞迴函數的調用堆疊會占用額外的空間。

2. 迭代解法：
   - 使用迭代的方式進行廣度優先搜索（BFS）。
   - 使用兩個佇列分別儲存兩個二叉樹的節點，並逐個比較對應位置上的節點值。
   - 迭代解法相對複雜一些，需要使用佇列來存儲節點並進行遍歷。
   - 迭代解法的時間複雜度和空間複雜度也均為 O(n)，其中 n 是二叉樹中的節點數量。迭代過程中需要遍歷所有節點進行比較，並且需要使用兩個佇列來存儲節點。

總體而言，遞迴解法較為簡潔直觀，而迭代解法則需要額外的佇列來存儲節點，稍微複雜一些。兩者的時間和空間複雜度相同，具體使用哪種解法可以根據個人偏好和需求來選擇。
