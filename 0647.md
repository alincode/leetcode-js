# 647. Palindromic Substrings

這道問題是計算字符串中的回文子串數量。回文子串是指正向和反向讀取相同的子串。

## 擴展中心法 解法

```javascript
var countSubstrings = function (s) {
  let count = 0;

  // 擴展中心法
  const expandAroundCenter = function (left, right) {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
      count++;
      left--;
      right++;
    }
  };

  // 遍歷每個字符，作為回文串的中心或中心的左側
  for (let i = 0; i < s.length; i++) {
    expandAroundCenter(i, i); // 單個字符作為中心
    expandAroundCenter(i, i + 1); // 兩個相同字符作為中心
  }

  return count;
};
```

這個解法使用擴展中心法來計算回文子串的數量。從每個字符開始，向左右擴展，如果遇到相同的字符，則回文子串的數量加 1。在遍歷過程中，考慮單個字符作為中心和兩個相同字符作為中心的情況。

該解法的時間複雜度是 O(n^2)，其中 n 是字符串的長度。在最壞的情況下，需要遍歷每個字符，並以每個字符為中心擴展。

空間複雜度是 O(1)，只使用了有限的額外空間。

### 什麼是擴展中心法？

擴展中心法（Expanding from the Center）是一種用於找出回文子串的有效方法。該方法的基本思想是從每個可能的中心位置開始，向兩側擴展，以找到所有的回文子串。

擴展中心法的具體步驟如下：

1. 遍歷字符串中的每個字符，將其作為中心字符。
2. 對於每個中心字符，向兩側擴展，判斷左右兩個字符是否相等，直到不再滿足回文條件為止。
3. 每次擴展時，計算回文子串的數量。

具體實現如下：

```javascript
var countSubstrings = function (s) {
  let count = 0;

  // 擴展中心為單個字符的情況
  for (let i = 0; i < s.length; i++) {
    count += expandAroundCenter(s, i, i); // 單個字符為中心
  }

  // 擴展中心為兩個字符的情況
  for (let i = 0; i < s.length - 1; i++) {
    count += expandAroundCenter(s, i, i + 1); // 兩個字符為中心
  }

  return count;
};

// 擴展中心，返回以left和right為中心的回文子串的數量
function expandAroundCenter(s, left, right) {
  let count = 0;

  while (left >= 0 && right < s.length && s[left] === s[right]) {
    count++;
    left--;
    right++;
  }

  return count;
}
```

擴展中心法的時間複雜度為 O(n^2)，其中 n 是字符串的長度。我們需要遍歷每個字符，並在每個字符位置上進行擴展，因此時間複雜度為 O(n^2)。

空間複雜度為 O(1)，因為我們只使用了固定數量的變量來存儲結果和遍歷索引，沒有使用額外的數據結構。

## DP 解法

是的，還有其他解法可以計算回文子串的數量。其中一種常見的解法是使用動態規劃（Dynamic Programming）。

動態規劃的思路是利用已知的回文子串來計算更長的回文子串。我們可以使用一個二維數組 `dp`，其中 `dp[i][j]` 表示從索引 `i` 到索引 `j` 的子串是否為回文串。

具體的解法如下：

```javascript
var countSubstrings = function (s) {
  const n = s.length;
  let count = 0;
  const dp = Array.from({ length: n }, () => new Array(n).fill(false));

  // 初始化單個字符為回文串
  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
    count++;
  }

  // 遍歷所有長度大於1的子串，計算是否為回文串
  for (let len = 2; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      if (s[i] === s[j]) {
        // 如果兩個邊界字符相同，且內部子串為回文串，則整個子串也為回文串
        if (len === 2 || dp[i + 1][j - 1]) {
          dp[i][j] = true;
          count++;
        }
      }
    }
  }

  return count;
};
```

這個解法的時間複雜度為 O(n^2)，其中 n 是字符串的長度。我們需要填充二維數組 `dp`，並在每一步中判斷子串是否為回文串。

空間複雜度也是 O(n^2)，因為我們使用了一個二維數組 `dp` 來存儲計算結果。

## 雙重循環 解法

```js
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function (s) {
  let result = 0;

  for (let i = 0; i < s.length; i++) {
    // odd palindrome
    let l = i;
    let r = i;

    while (l > -1 && r < s.length && s.charAt(l) === s.charAt(r)) {
      result++;

      l--;
      r++;
    }

    // even palindrome
    l = i;
    r = i + 1;

    while (l > -1 && r < s.length && s.charAt(l) === s.charAt(r)) {
      result++;

      l--;
      r++;
    }
  }

  return result;
};
```

這個解法使用了一個雙重循環，對於每個字符，同時檢查奇數長度的回文子串和偶數長度的回文子串。

具體分析如下：

1. 初始化計數器 `result` 為 0。
2. 遍歷字符串 `s` 的每個字符，假設當前字符的索引為 `i`。
3. 對於每個字符，先找到以該字符為中心的奇數長度的回文子串。初始化兩個指針 `l` 和 `r` 分別指向 `i`，並向兩側擴展，檢查字符是否相等。當左右指針指向的字符相等時，表示找到一個回文子串，將計數器 `result` 增加 1，同時將左指針 `l` 往左移一位，右指針 `r` 往右移一位。重複進行這個過程，直到左右指針越界或字符不相等為止。
4. 接下來，對於每個字符，找到以該字符及其下一個字符為中心的偶數長度的回文子串。初始化左指針 `l` 為 `i`，右指針 `r` 為 `i+1`，並進行擴展和檢查的過程，同樣將計數器 `result` 增加 1。
5. 繼續遍歷下一個字符，重複步驟 3 和步驟 4，直到遍歷完所有字符。
6. 返回計數器 `result`，即為回文子串的總數。

該解法的時間複雜度為 O(n^2)，其中 n 是字符串的長度。因為對於每個字符，我們都需要擴展兩次（奇數和偶數），並且擴展的範圍隨著字符串長度增加而增加，所以總體時間複雜度為 O(n^2)。

空間複雜度為 O(1)，因為我們只使用了固定數量的變量來存儲結果和遍歷索引，沒有使用額外的數據結構。
