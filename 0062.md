# 62. Unique Paths

這個問題是一個經典的動態規劃問題，稱為「唯一路徑」問題（Unique Paths）。問題描述如下：

給定一個 m × n 的網格，從網格的左上角出發，每次只能向右或向下移動一步，最終到達網格的右下角。求從起點到終點的所有不同路徑的數量。

例如，當 m = 3、n = 2 時，網格如下所示：

```
1 1
1 1
1 1
```

從起點到終點的不同路徑有 3 條。

## DP 解法

這個問題可以使用動態規劃的方法來解決。我們可以定義一個二維陣列 dp，其中 dp[i][j] 表示從起點到網格的位置 (i, j) 的不同路徑數量。根據問題的特性，我們可以得到以下狀態轉移方程：

- 當 i = 0 或 j = 0 時，表示在第一行或第一列的位置，只有一條路徑可以到達，因此 dp[i][j] = 1。
- 對於其他位置 (i, j)，可以從上方 (i-1, j) 或左方 (i, j-1) 進行移動，因此 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。

根據狀態轉移方程，我們可以遍歷網格，從左上角到右下角計算不同位置的路徑數量，最終得到終點的不同路徑數量。

以下是對應的程式碼：

```javascript
var uniquePaths = function (m, n) {
  // 創建二維陣列 dp
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

  // 初始化第一行和第一列的值為 1
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1;
  }
  for (let j = 0; j < n; j++) {
    dp[0][j] = 1;
  }

  // 遍歷網格，計算不同位置的路徑數量
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
  }

  // 返回終點的路徑數量
  return dp[m - 1][n - 1];
};
```

這個算法的時間複雜度是 O(m × n)，其中 m 是網格的行數，n 是網格的列數。由於我們需要遍歷整個網格一次，並計算每個位置的路徑數量。空間複雜度也是 O(m × n)，我們使用了一個二維陣列 dp 來存儲中間結果。

## 計算組合數

是的，除了動態規劃的解法之外，還可以使用組合數學的思想來解決這個問題。

根據問題的要求，我們需要從起點到終點總共移動 (m-1) + (n-1) = m + n - 2 步，其中有 m-1 步是向下移動，n-1 步是向右移動。我們可以將問題轉化為在這些步驟中選擇 m-1 步向下移動的組合數。

根據組合數的定義，組合數 C(n, k) 表示從 n 個元素中選擇 k 個元素的組合數量。在本問題中，我們需要計算 C(m+n-2, m-1)。根據組合數的性質，我們可以使用動態規劃或數學公式來計算組合數。

以下是使用數學公式計算組合數的程式碼：

```javascript
var uniquePaths = function (m, n) {
  // 計算組合數 C(m+n-2, m-1)
  const totalSteps = m + n - 2;
  const downSteps = m - 1;
  let result = 1;

  for (let i = 1; i <= downSteps; i++) {
    result = (result * (totalSteps - downSteps + i)) / i;
  }

  return Math.round(result);
};
```

這個解法的時間複雜度是 O(min(m, n))，空間複雜度是 O(1)。由於我們只需要計算組合數，不需要遍歷整個網格。
