# 79. Word Search

這是一個在二維字符矩陣中尋找指定單詞的問題。我們需要判斷在矩陣中是否存在一條由相鄰字符組成的路徑，該路徑可以構成給定的單詞。

## DFS 解法

以下是使用 JavaScript 實現的解答：

```javascript
var exist = function (board, word) {
  const m = board.length;
  const n = board[0].length;
  const visited = Array.from(Array(m), () => Array(n).fill(false));

  const dfs = function (row, col, index) {
    // 判斷邊界條件和字母匹配情況
    if (
      row < 0 ||
      row >= m ||
      col < 0 ||
      col >= n ||
      visited[row][col] ||
      board[row][col] !== word[index]
    ) {
      return false;
    }

    // 已經找到了完整的單詞
    if (index === word.length - 1) {
      return true;
    }

    // 標記當前位置已訪問
    visited[row][col] = true;

    // 遞歸搜索上下左右四個方向
    const found =
      dfs(row - 1, col, index + 1) ||
      dfs(row + 1, col, index + 1) ||
      dfs(row, col - 1, index + 1) ||
      dfs(row, col + 1, index + 1);

    // 回溯，標記當前位置為未訪問
    visited[row][col] = false;

    return found;
  };

  // 遍歷矩陣的每個位置，進行搜索
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (dfs(i, j, 0)) {
        return true;
      }
    }
  }

  return false;
};
```

這個解答使用了深度優先搜索（DFS）的方法來在矩陣中尋找單詞的路徑。我們定義了一個遞歸函數 `dfs`，該函數接收三個參數：當前位置的行 `row`、當前位置的列 `col`、當前要匹配的單詞字符的索引 `index`。在每次遞歸中，我們首先檢查當前位置是否合法並且字符匹配，如果不滿足條件則返回 false。如果已經匹配到了單詞的最後一個字符，表示找到了一個符合要求的路徑，返回 true。否則，我們將當前位置標記為已訪問，並遞歸搜索上下左右四個方向的相鄰位置。搜索完成後，我們需要回溯，

DFS 解法的時間複雜度是 `O(m * n * 4^k)`，其中 m 和 n 分別是矩陣的行數和列數，k 是單詞的長度。這是因為在最壞情況下，DFS 可能會遍歷每個格子，並且對於每個格子，都有四個可能的相鄰格子可以選擇。

空間複雜度是 O(k)，其中 k 是單詞的長度。這是因為在 DFS 遞歸的過程中，需要使用一個遞歸棧來保存遞歸的狀態。由於遞歸的深度最多為單詞的長度，因此遞歸棧的空間複雜度為 O(k)。此外，還需要一個額外的 visited 矩陣來標記已訪問過的位置，其大小也是 `O(m * n)`。

總結起來，DFS 解法的空間複雜度主要由遞歸棧和 visited 矩陣決定，均與輸入的矩陣大小和單詞的長度有關。在最壞情況下，空間複雜度為 `O(m * n + k)`。

## BFS 解法

對於該問題，使用 BFS 的解法需要注意一些細節。在 BFS 中，需要使用一個隊列（queue）來保存待處理的節點，並使用一個 visited 矩陣來標記已訪問過的位置。

以下是一個修改後的 BFS 解法：

```javascript
var exist = function (board, word) {
  const m = board.length;
  const n = board[0].length;
  const directions = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1],
  ];

  const bfs = (i, j, index) => {
    if (index === word.length) {
      return true;
    }

    if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] !== word[index]) {
      return false;
    }

    const temp = board[i][j];
    board[i][j] = "#"; // Mark the cell as visited

    for (const [dx, dy] of directions) {
      if (bfs(i + dx, j + dy, index + 1)) {
        return true;
      }
    }

    board[i][j] = temp; // Restore the cell value
    return false;
  };

  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (bfs(i, j, 0)) {
        return true;
      }
    }
  }

  return false;
};
```

這個修改後的 BFS 解法使用遞歸來進行搜索，每次檢查當前位置的字母是否匹配，並根據字母匹配與否進行相應的處理。如果搜索到目標單詞的末尾，則返回 true；如果搜索超出矩陣邊界或當前位置的字母不匹配，則返回 false。

請注意，這個解法在搜索過程中直接修改了原始的矩陣，將已訪問的位置標記為 "#"。這樣做的目的是為了避免在同一條搜索路徑中重複訪問同一個位置。

請使用以上修改後的 BFS 解法重新測試，確保結果的正確性。
